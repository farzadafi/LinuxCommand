# Chapter 2. Unit Tests
پس از بخش های مقدماتی کتاب که به طور کلی به تست های توسعه دهندگان اختصاص داده شده بود، حالا به سراغ موضوع اصلی کتاب میریم: unit test
#### آ 2.1 تست های واحد چه چیزی هستن؟
ایده ای که پشت تست های واحد هستش ساده اس: این هستش که اطمینان پیدا کنیم از اینکه کلاسی که الان داریم روش کار میکنیم به درستی کار میکنه تا مطمئن شیم کار خودش رو انجام میده. این موضوع که عنوان شد به این مربوط میشه که که به ازای ورودی ای خاص خروجیه مورد انتظاری میده یا نه، یا اینکه اگه اون رو با خروجی های مزخرف پر کنیم، خطای مناسب بده. ایده اینه، نوشتن تست برای اعتبارسنجی کردن رفتار مورد انتظار.

اما این کافی نیست. شما باید کلاساتون رو تست کنید به صورت مجزا و ایزوله، و تست کنید تا اعتبارسنجی کنید تا اونها داخل هر محیطی کار میکنن. وقتی که ما تست واحد مینویسیم خیلی مهمه که فقط یه دونه کلاس رو تست کنیم و نه بیشتر. روی منطق کلاستون تمرکز کنید. زمانی که مطمئن شدین کدتون به خوبی کار میکنه، بعدش با بقیه کامپوننت ها تست یکپارچگی انجام بدین. اما اول تست های واحد رو انجام بدین.

اخطار: متاسفانه حتی الان خیلی ها تست های واحد رو با سایر تست ها اشتباه میگیرن)شما میتونید مطالعه کنید راجع به تست واحد دیتابیس(یا استفاده میشه از این واژه برای هر تستی که توسعه دهندگان مینویسند. بسیاری از افراد ادعا میکنن که همه تست هاشون از نوع یونیت هستش، فقط به این علت که اونها با فریم ورک های یونیت تست اجرا میشن! برخی دیگر ادعا میکنن که اونها دارن تست واحد مینویسن و سه لایه از نرم افزار رو برای نوشتن تست واحد انتخاب کردن... این البته که اشتباهه، این سردرگمی به وجود میاره و بحث رو سخت میکنه. اینکار رو انجام ندین! شما واقعا میدونید تست واحد چیه.

تست های واحد برخی از خصوصیات رو دارن که اونها رو از سایر تست های برنامه نویسان متمایز میکنه. اونها روی یه دونه کلاس تمرکز میکنن و به شدت شرایطی رو که  SUT  در اون در حال اجرا هستش رو کنترل میکنن. اونها همچنین خیلی سریع اجرا میشن و توانایی این رو دارن که با دقت خوبی نقطه سنجی کنن جایی که باگ به وجود آورده رو، اغلب اوقات  متد خراب رو به توسعه دهنده نشون میدن اگه نشون ندن اون خط کد خراب رو! با این چنین فیدبک های سریع و دقیقی در مورد کیفیت کار، اونها کمک میکنن که به سرعت باگ رو حل کنیم قبل از اینکه در کل برنامه پخش شن.

وجود تست های جامع و دقیق واحد به ما اجازه میده که بدون ترس از اینکه چیزی خراب شه کد رو ریفکتور کنیم، وقتی که کلاس های شما توسط یونیت تست کاملا پوشش داده شدن، هیچ جایی از کد شما نمیمونه که "هیچکس جرات دست زدن بهش رو نداره".

مزیت دیگر تست های واحد اینکه اونها به عنوان یک سند زنده)اونها همیشه به روزن(برای کد شما  استفاده میشن. اونها خیلی بیشتر از جاواداک و انواع دیگر توضیحات خطی که برنامه نویسان در هنگام توسعه برای کد خودشون نوشتن، قابل اعتمادن.

آخرین و نه کم اهمیت، یک توسعه دهنده ماهر میتونه فرآیند ایجاد تست های واحد رو به یک فعالیت طراحی تبدیل کنه. این، خیلی شگفت انگیزه، احتمالا این مهم ترین مزیت تست های واحده

اخطار: یک چیز دیگه هم به یاد داشته باشید: تست های واحد توسط برنامه نویسان ایجاد شدن، و این مسئولیت ما، ابزار ما و  چیزیه که بهش افتخار میکنیم و اگر به خوبی انجامش ندیم باید بابت اون شرمنده باشیم.

#### آ 2.2 تعامل در تست های واحد

برای اینکه بدونیم چه چیزی باید در تست های واحد تست شه و چگونه، ما باید نگاه نزدیک تری به تعاملات بین کلاس تستمون و SUT و بین SUT و DOC داشته باشیم.

ابتدا برخی از نظریه ها رو در قالب یه شکل ببینیم. شکل زیر حالت های مختلف تعامل بین SUT و دیگر اجزا رو نشون میده:
IIIIIIIIIIIIImage HERE :)

دو تا از تعاملات اینجا مستقیم هستن و شامل کلاس های SUT و کاربرش میشن)که در این یوزکیس منظور از کاربر همون کلاس تست هستش(عمل بر روی این دو تا خیلی آسونه و اونها مستقیما از داخل کد تست در دسترس هستند. دو تای تعامل دیگه از نوع غیرمستقیم هستن که شامل تعاملات SUT و DOC میشن. در این یوزکیس کاربر)کلاس تست(راهی برای دسترسی گرفتن مستقیم و تعامل مستقیم با DOC نداره.

یک راه ممکن دیگه برای طبقه بندی کردن تعاملات ورودی ها)وقتی که SUT پیامی رو دریافت میکنه(و خروجی ها)زمانی که SUT چیزی رو ارسال میکنه(هستن. در هنگام تست کردن ما از ورودی های مسقتیم و غیرمستقیم برای تنظیم کردن SUT در وضعیتی که بهش نیاز داریم و فراخوانی متد هاش استفاده میکنیم. خروجی های مسقیم و غیرمستقیم SUT بیانگر رفتار SUT هستن. این به این معنیه که ما باید استفاده کنیم از اینها برای اینکه ببینیم SUT رفتار مناسبی داره یا نه.

جدول زیر به صورت خلاصه انواع حالت های مختلف تعامل بین SUT و DOC رو بیان کرده. ستون اول که اسمش "نوع تعامل" هستش، توضیح میده که نوع تعامل از دید SUT چیه. یک کلاس تست به عنوان کاربر کلاسی که میخواد تست کنه عمل میکنه، بنابراین در ستون "طرف های دیگر" نمایش داده شده است.


|    نوع تعامل    | طرف های درگیر  | توضیحات                                                                                                         |
| :-------------: | :------------: | :-------------------------------------------------------------------------------------------------------------- |
|  ورودی مستقیم   | کلاس تست و SUT | متد SUT صدا زده میشه                                                                                            |
|  خروجی مستقیم   | کلاس تست و SUT | بعد از اینکه متد SUT صدا زده میشه، یک نتیجه به کلاس تست برگردانده میشود.                                        |
| خروجی غیرمستقیم |   SUT & DOC    | مقداری توسط SUT به سمت متد هایی که باهاشون تعامل داره ارسال میشه.                                               |
| ورودی غیرمستقیم |   SUT & DOC    | بعد از اینکه SUT یکی از متد های متعاملین خودش رو صدا میزنه، یا خروجی بهش برمیگرده و یا اینکه یه خطا پرتاب میشه. |

یک مثال کدی تمامی موارد بالا رو شفاف میسازه. لطفا تصور کنید که مواردی از financial service داریم که بر طبق آخرین پرداخت مشتری و نوع آن، برخی امتیاز ها و پاداش ها رو محاسبه میکنه.

Image 2222222222.22222222 is HERE :)

همون طوری که داخل SUT که اینجا متد calculateBonus هستش میبینید که دو تا پارامتر ورودی میگیره)یکی clientId و یکی دیگه payment هستش(و با دو تا کلاس دیگه تعامل داره)که یکی clientDAO هستش و یکی calculator هستش(. برای آزمایش کامل متد calculateBonus ما نیاز داریم که کنترل کنیم پارامتر های ورودی این متد رو)ورودی های مسقیم(و پیام هایی که از متعاملین این متد)ورودی های غیرمسقیم(میادش. سپس ما میتونیم ببینیم آیا خروجی این متد)خروجی مستقیم(درست هستش یا نه.

جدول زیر انواع تعاملاتی که اتفاق میفته داخل متد calculateBonus رو خلاصه کرده:


|    نوع تعامل    | طرف های درگیر  | توضیحات                                                                                                                                                              |
| :-------------: | :------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|  ورودی مستقیم   | کلاس تست و SUT | ورودی هایی که مستقیما به متد calculateBonus داده میشن: clientId & payment                                                                                            |
|   خرجی مستقیم   | کلاس تست و SUT | خروجی متد calculateBonus که bonus هستش پس از محاسبه این مقدار توسط متد مورد نظر                                                                                      |
| خورجی غیرمستقیم |   SUT & DOC    | مقدار clientId & bonus به کلاس clientDAO پاس داده میشن تا برای تاریخچه ذخیره شن.<br>مقدار clientType & payment به کلاس calculator پاس داده میشن تا محاسبه صورت گیرد. |
| ورودی غیرمستقیم |   SUT & DOC    | مقدار clientType برگردونه میشه توسط clientDAO و مقدار bonus که توسط calculator به SUT برگردونه میشن                                                                  |

آ 2.2.1 تست حالت VS تست تعامل









